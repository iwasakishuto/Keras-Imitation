var tipuesearch = {"pages":[{"title":"NeuralNetworks","text":"/*! * * IPython notebook * */ /* CSS font colors for translated ANSI escape sequences */ /* The color values are a mix of http://www.xcolors.net/dl/baskerville-ivorylight and http://www.xcolors.net/dl/euphrasia */ .ansi-black-fg { color: #3E424D; } .ansi-black-bg { background-color: #3E424D; } .ansi-black-intense-fg { color: #282C36; } .ansi-black-intense-bg { background-color: #282C36; } .ansi-red-fg { color: #E75C58; } .ansi-red-bg { background-color: #E75C58; } .ansi-red-intense-fg { color: #B22B31; } .ansi-red-intense-bg { background-color: #B22B31; } .ansi-green-fg { color: #00A250; } .ansi-green-bg { background-color: #00A250; } .ansi-green-intense-fg { color: #007427; } .ansi-green-intense-bg { background-color: #007427; } .ansi-yellow-fg { color: #DDB62B; } .ansi-yellow-bg { background-color: #DDB62B; } .ansi-yellow-intense-fg { color: #B27D12; } .ansi-yellow-intense-bg { background-color: #B27D12; } .ansi-blue-fg { color: #208FFB; } .ansi-blue-bg { background-color: #208FFB; } .ansi-blue-intense-fg { color: #0065CA; } .ansi-blue-intense-bg { background-color: #0065CA; } .ansi-magenta-fg { color: #D160C4; } .ansi-magenta-bg { background-color: #D160C4; } .ansi-magenta-intense-fg { color: #A03196; } .ansi-magenta-intense-bg { background-color: #A03196; } .ansi-cyan-fg { color: #60C6C8; } .ansi-cyan-bg { background-color: #60C6C8; } .ansi-cyan-intense-fg { color: #258F8F; } .ansi-cyan-intense-bg { background-color: #258F8F; } .ansi-white-fg { color: #C5C1B4; } .ansi-white-bg { background-color: #C5C1B4; } .ansi-white-intense-fg { color: #A1A6B2; } .ansi-white-intense-bg { background-color: #A1A6B2; } .ansi-default-inverse-fg { color: #FFFFFF; } .ansi-default-inverse-bg { background-color: #000000; } .ansi-bold { font-weight: bold; } .ansi-underline { text-decoration: underline; } /* The following styles are deprecated an will be removed in a future version */ .ansibold { font-weight: bold; } .ansi-inverse { outline: 0.5px dotted; } /* use dark versions for foreground, to improve visibility */ .ansiblack { color: black; } .ansired { color: darkred; } .ansigreen { color: darkgreen; } .ansiyellow { color: #c4a000; } .ansiblue { color: darkblue; } .ansipurple { color: darkviolet; } .ansicyan { color: steelblue; } .ansigray { color: gray; } /* and light for background, for the same reason */ .ansibgblack { background-color: black; } .ansibgred { background-color: red; } .ansibggreen { background-color: green; } .ansibgyellow { background-color: yellow; } .ansibgblue { background-color: blue; } .ansibgpurple { background-color: magenta; } .ansibgcyan { background-color: cyan; } .ansibggray { background-color: gray; } div.cell { /* Old browsers */ display: -webkit-box; -webkit-box-orient: vertical; -webkit-box-align: stretch; display: -moz-box; -moz-box-orient: vertical; -moz-box-align: stretch; display: box; box-orient: vertical; box-align: stretch; /* Modern browsers */ display: flex; flex-direction: column; align-items: stretch; border-radius: 2px; box-sizing: border-box; -moz-box-sizing: border-box; -webkit-box-sizing: border-box; border-width: 1px; border-style: solid; border-color: transparent; width: 100%; padding: 5px; /* This acts as a spacer between cells, that is outside the border */ margin: 0px; outline: none; position: relative; overflow: visible; } div.cell:before { position: absolute; display: block; top: -1px; left: -1px; width: 5px; height: calc(100% + 2px); content: ''; background: transparent; } div.cell.jupyter-soft-selected { border-left-color: #E3F2FD; border-left-width: 1px; padding-left: 5px; border-right-color: #E3F2FD; border-right-width: 1px; background: #E3F2FD; } @media print { div.cell.jupyter-soft-selected { border-color: transparent; } } div.cell.selected, div.cell.selected.jupyter-soft-selected { border-color: #ababab; } div.cell.selected:before, div.cell.selected.jupyter-soft-selected:before { position: absolute; display: block; top: -1px; left: -1px; width: 5px; height: calc(100% + 2px); content: ''; background: #42A5F5; } @media print { div.cell.selected, div.cell.selected.jupyter-soft-selected { border-color: transparent; } } .edit_mode div.cell.selected { border-color: #66BB6A; } .edit_mode div.cell.selected:before { position: absolute; display: block; top: -1px; left: -1px; width: 5px; height: calc(100% + 2px); content: ''; background: #66BB6A; } @media print { .edit_mode div.cell.selected { border-color: transparent; } } .prompt { /* This needs to be wide enough for 3 digit prompt numbers: In[100]: */ min-width: 14ex; /* This padding is tuned to match the padding on the CodeMirror editor. */ padding: 0.4em; margin: 0px; font-family: monospace; text-align: right; /* This has to match that of the the CodeMirror class line-height below */ line-height: 1.21429em; /* Don't highlight prompt number selection */ -webkit-touch-callout: none; -webkit-user-select: none; -khtml-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; /* Use default cursor */ cursor: default; } @media (max-width: 540px) { .prompt { text-align: left; } } div.inner_cell { min-width: 0; /* Old browsers */ display: -webkit-box; -webkit-box-orient: vertical; -webkit-box-align: stretch; display: -moz-box; -moz-box-orient: vertical; -moz-box-align: stretch; display: box; box-orient: vertical; box-align: stretch; /* Modern browsers */ display: flex; flex-direction: column; align-items: stretch; /* Old browsers */ -webkit-box-flex: 1; -moz-box-flex: 1; box-flex: 1; /* Modern browsers */ flex: 1; } /* input_area and input_prompt must match in top border and margin for alignment */ div.input_area { border: 1px solid #cfcfcf; border-radius: 2px; background: #f7f7f7; line-height: 1.21429em; } /* This is needed so that empty prompt areas can collapse to zero height when there is no content in the output_subarea and the prompt. The main purpose of this is to make sure that empty JavaScript output_subareas have no height. */ div.prompt:empty { padding-top: 0; padding-bottom: 0; } div.unrecognized_cell { padding: 5px 5px 5px 0px; /* Old browsers */ display: -webkit-box; -webkit-box-orient: horizontal; -webkit-box-align: stretch; display: -moz-box; -moz-box-orient: horizontal; -moz-box-align: stretch; display: box; box-orient: horizontal; box-align: stretch; /* Modern browsers */ display: flex; flex-direction: row; align-items: stretch; } div.unrecognized_cell .inner_cell { border-radius: 2px; padding: 5px; font-weight: bold; color: red; border: 1px solid #cfcfcf; background: #eaeaea; } div.unrecognized_cell .inner_cell a { color: inherit; text-decoration: none; } div.unrecognized_cell .inner_cell a:hover { color: inherit; text-decoration: none; } @media (max-width: 540px) { div.unrecognized_cell > div.prompt { display: none; } } div.code_cell { /* avoid page breaking on code cells when printing */ } @media print { div.code_cell { page-break-inside: avoid; } } /* any special styling for code cells that are currently running goes here */ div.input { page-break-inside: avoid; /* Old browsers */ display: -webkit-box; -webkit-box-orient: horizontal; -webkit-box-align: stretch; display: -moz-box; -moz-box-orient: horizontal; -moz-box-align: stretch; display: box; box-orient: horizontal; box-align: stretch; /* Modern browsers */ display: flex; flex-direction: row; align-items: stretch; } @media (max-width: 540px) { div.input { /* Old browsers */ display: -webkit-box; -webkit-box-orient: vertical; -webkit-box-align: stretch; display: -moz-box; -moz-box-orient: vertical; -moz-box-align: stretch; display: box; box-orient: vertical; box-align: stretch; /* Modern browsers */ display: flex; flex-direction: column; align-items: stretch; } } /* input_area and input_prompt must match in top border and margin for alignment */ div.input_prompt { color: #303F9F; border-top: 1px solid transparent; } div.input_area > div.highlight { margin: 0.4em; border: none; padding: 0px; background-color: transparent; } div.input_area > div.highlight > pre { margin: 0px; border: none; padding: 0px; background-color: transparent; } /* The following gets added to the <head> if it is detected that the user has a * monospace font with inconsistent normal/bold/italic height. See * notebookmain.js. Such fonts will have keywords vertically offset with * respect to the rest of the text. The user should select a better font. * See: https://github.com/ipython/ipython/issues/1503 * * .CodeMirror span { * vertical-align: bottom; * } */ .CodeMirror { line-height: 1.21429em; /* Changed from 1em to our global default */ font-size: 14px; height: auto; /* Changed to auto to autogrow */ background: none; /* Changed from white to allow our bg to show through */ } .CodeMirror-scroll { /* The CodeMirror docs are a bit fuzzy on if overflow-y should be hidden or visible.*/ /* We have found that if it is visible, vertical scrollbars appear with font size changes.*/ overflow-y: hidden; overflow-x: auto; } .CodeMirror-lines { /* In CM2, this used to be 0.4em, but in CM3 it went to 4px. We need the em value because */ /* we have set a different line-height and want this to scale with that. */ /* Note that this should set vertical padding only, since CodeMirror assumes that horizontal padding will be set on CodeMirror pre */ padding: 0.4em 0; } .CodeMirror-linenumber { padding: 0 8px 0 4px; } .CodeMirror-gutters { border-bottom-left-radius: 2px; border-top-left-radius: 2px; } .CodeMirror pre { /* In CM3 this went to 4px from 0 in CM2. This sets horizontal padding only, use .CodeMirror-lines for vertical */ padding: 0 0.4em; border: 0; border-radius: 0; } .CodeMirror-cursor { border-left: 1.4px solid black; } @media screen and (min-width: 2138px) and (max-width: 4319px) { .CodeMirror-cursor { border-left: 2px solid black; } } @media screen and (min-width: 4320px) { .CodeMirror-cursor { border-left: 4px solid black; } } /* Original style from softwaremaniacs.org (c) Ivan Sagalaev <Maniac@SoftwareManiacs.Org> Adapted from GitHub theme */ .highlight-base { color: #000; } .highlight-variable { color: #000; } .highlight-variable-2 { color: #1a1a1a; } .highlight-variable-3 { color: #333333; } .highlight-string { color: #BA2121; } .highlight-comment { color: #408080; font-style: italic; } .highlight-number { color: #080; } .highlight-atom { color: #88F; } .highlight-keyword { color: #008000; font-weight: bold; } .highlight-builtin { color: #008000; } .highlight-error { color: #f00; } .highlight-operator { color: #AA22FF; font-weight: bold; } .highlight-meta { color: #AA22FF; } /* previously not defined, copying from default codemirror */ .highlight-def { color: #00f; } .highlight-string-2 { color: #f50; } .highlight-qualifier { color: #555; } .highlight-bracket { color: #997; } .highlight-tag { color: #170; } .highlight-attribute { color: #00c; } .highlight-header { color: blue; } .highlight-quote { color: #090; } .highlight-link { color: #00c; } /* apply the same style to codemirror */ .cm-s-ipython span.cm-keyword { color: #008000; font-weight: bold; } .cm-s-ipython span.cm-atom { color: #88F; } .cm-s-ipython span.cm-number { color: #080; } .cm-s-ipython span.cm-def { color: #00f; } .cm-s-ipython span.cm-variable { color: #000; } .cm-s-ipython span.cm-operator { color: #AA22FF; font-weight: bold; } .cm-s-ipython span.cm-variable-2 { color: #1a1a1a; } .cm-s-ipython span.cm-variable-3 { color: #333333; } .cm-s-ipython span.cm-comment { color: #408080; font-style: italic; } .cm-s-ipython span.cm-string { color: #BA2121; } .cm-s-ipython span.cm-string-2 { color: #f50; } .cm-s-ipython span.cm-meta { color: #AA22FF; } .cm-s-ipython span.cm-qualifier { color: #555; } .cm-s-ipython span.cm-builtin { color: #008000; } .cm-s-ipython span.cm-bracket { color: #997; } .cm-s-ipython span.cm-tag { color: #170; } .cm-s-ipython span.cm-attribute { color: #00c; } .cm-s-ipython span.cm-header { color: blue; } .cm-s-ipython span.cm-quote { color: #090; } .cm-s-ipython span.cm-link { color: #00c; } .cm-s-ipython span.cm-error { color: #f00; } .cm-s-ipython span.cm-tab { background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAMCAYAAAAkuj5RAAAAAXNSR0IArs4c6QAAAGFJREFUSMft1LsRQFAQheHPowAKoACx3IgEKtaEHujDjORSgWTH/ZOdnZOcM/sgk/kFFWY0qV8foQwS4MKBCS3qR6ixBJvElOobYAtivseIE120FaowJPN75GMu8j/LfMwNjh4HUpwg4LUAAAAASUVORK5CYII=); background-position: right; background-repeat: no-repeat; } div.output_wrapper { /* this position must be relative to enable descendents to be absolute within it */ position: relative; /* Old browsers */ display: -webkit-box; -webkit-box-orient: vertical; -webkit-box-align: stretch; display: -moz-box; -moz-box-orient: vertical; -moz-box-align: stretch; display: box; box-orient: vertical; box-align: stretch; /* Modern browsers */ display: flex; flex-direction: column; align-items: stretch; z-index: 1; } /* class for the output area when it should be height-limited */ div.output_scroll { /* ideally, this would be max-height, but FF barfs all over that */ height: 24em; /* FF needs this *and the wrapper* to specify full width, or it will shrinkwrap */ width: 100%; overflow: auto; border-radius: 2px; -webkit-box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.8); box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.8); display: block; } /* output div while it is collapsed */ div.output_collapsed { margin: 0px; padding: 0px; /* Old browsers */ display: -webkit-box; -webkit-box-orient: vertical; -webkit-box-align: stretch; display: -moz-box; -moz-box-orient: vertical; -moz-box-align: stretch; display: box; box-orient: vertical; box-align: stretch; /* Modern browsers */ display: flex; flex-direction: column; align-items: stretch; } div.out_prompt_overlay { height: 100%; padding: 0px 0.4em; position: absolute; border-radius: 2px; } div.out_prompt_overlay:hover { /* use inner shadow to get border that is computed the same on WebKit/FF */ -webkit-box-shadow: inset 0 0 1px #000; box-shadow: inset 0 0 1px #000; background: rgba(240, 240, 240, 0.5); } div.output_prompt { color: #D84315; } /* This class is the outer container of all output sections. */ div.output_area { padding: 0px; page-break-inside: avoid; /* Old browsers */ display: -webkit-box; -webkit-box-orient: horizontal; -webkit-box-align: stretch; display: -moz-box; -moz-box-orient: horizontal; -moz-box-align: stretch; display: box; box-orient: horizontal; box-align: stretch; /* Modern browsers */ display: flex; flex-direction: row; align-items: stretch; } div.output_area .MathJax_Display { text-align: left !important; } div.output_area div.output_area div.output_area img, div.output_area svg { max-width: 100%; height: auto; } div.output_area img.unconfined, div.output_area svg.unconfined { max-width: none; } div.output_area .mglyph > img { max-width: none; } /* This is needed to protect the pre formating from global settings such as that of bootstrap */ .output { /* Old browsers */ display: -webkit-box; -webkit-box-orient: vertical; -webkit-box-align: stretch; display: -moz-box; -moz-box-orient: vertical; -moz-box-align: stretch; display: box; box-orient: vertical; box-align: stretch; /* Modern browsers */ display: flex; flex-direction: column; align-items: stretch; } @media (max-width: 540px) { div.output_area { /* Old browsers */ display: -webkit-box; -webkit-box-orient: vertical; -webkit-box-align: stretch; display: -moz-box; -moz-box-orient: vertical; -moz-box-align: stretch; display: box; box-orient: vertical; box-align: stretch; /* Modern browsers */ display: flex; flex-direction: column; align-items: stretch; } } div.output_area pre { margin: 0; padding: 1px 0 1px 0; border: 0; vertical-align: baseline; color: black; background-color: transparent; border-radius: 0; } /* This class is for the output subarea inside the output_area and after the prompt div. */ div.output_subarea { overflow-x: auto; padding: 0.4em; /* Old browsers */ -webkit-box-flex: 1; -moz-box-flex: 1; box-flex: 1; /* Modern browsers */ flex: 1; max-width: calc(100% - 14ex); } div.output_scroll div.output_subarea { overflow-x: visible; } /* The rest of the output_* classes are for special styling of the different output types */ /* all text output has this class: */ div.output_text { text-align: left; color: #000; /* This has to match that of the the CodeMirror class line-height below */ line-height: 1.21429em; } /* stdout/stderr are 'text' as well as 'stream', but execute_result/error are *not* streams */ div.output_stderr { background: #fdd; /* very light red background for stderr */ } div.output_latex { text-align: left; } /* Empty output_javascript divs should have no height */ div.output_javascript:empty { padding: 0; } .js-error { color: darkred; } /* raw_input styles */ div.raw_input_container { line-height: 1.21429em; padding-top: 5px; } pre.raw_input_prompt { /* nothing needed here. */ } input.raw_input { font-family: monospace; font-size: inherit; color: inherit; width: auto; /* make sure input baseline aligns with prompt */ vertical-align: baseline; /* padding + margin = 0.5em between prompt and cursor */ padding: 0em 0.25em; margin: 0em 0.25em; } input.raw_input:focus { box-shadow: none; } p.p-space { margin-bottom: 10px; } div.output_unrecognized { padding: 5px; font-weight: bold; color: red; } div.output_unrecognized a { color: inherit; text-decoration: none; } div.output_unrecognized a:hover { color: inherit; text-decoration: none; } .rendered_html { color: #000; /* any extras will just be numbers: */ } .rendered_html :link { text-decoration: underline; } .rendered_html :visited { text-decoration: underline; } .rendered_html h1:first-child { margin-top: 0.538em; } .rendered_html h2:first-child { margin-top: 0.636em; } .rendered_html h3:first-child { margin-top: 0.777em; } .rendered_html h4:first-child { margin-top: 1em; } .rendered_html h5:first-child { margin-top: 1em; } .rendered_html h6:first-child { margin-top: 1em; } .rendered_html ul:not(.list-inline), .rendered_html ol:not(.list-inline) { padding-left: 2em; } .rendered_html * + ul { margin-top: 1em; } .rendered_html * + ol { margin-top: 1em; } .rendered_html pre, .rendered_html tr, .rendered_html th, .rendered_html tbody tr:nth-child(odd) { background: #f5f5f5; } .rendered_html tbody tr:hover { background: rgba(66, 165, 245, 0.2); } .rendered_html * + table { margin-top: 1em; } .rendered_html * + p { margin-top: 1em; } .rendered_html * + img { margin-top: 1em; } .rendered_html img, .rendered_html img.unconfined, .rendered_html * + .alert { margin-top: 1em; } [dir=\"rtl\"] div.text_cell { /* Old browsers */ display: -webkit-box; -webkit-box-orient: horizontal; -webkit-box-align: stretch; display: -moz-box; -moz-box-orient: horizontal; -moz-box-align: stretch; display: box; box-orient: horizontal; box-align: stretch; /* Modern browsers */ display: flex; flex-direction: row; align-items: stretch; } @media (max-width: 540px) { div.text_cell > div.prompt { display: none; } } div.text_cell_render { /*font-family: \"Helvetica Neue\", Arial, Helvetica, Geneva, sans-serif;*/ outline: none; resize: none; width: inherit; border-style: none; padding: 0.5em 0.5em 0.5em 0.4em; color: #000; box-sizing: border-box; -moz-box-sizing: border-box; -webkit-box-sizing: border-box; } a.anchor-link:link { text-decoration: none; padding: 0px 20px; visibility: hidden; } h1:hover .anchor-link, h2:hover .anchor-link, h3:hover .anchor-link, h4:hover .anchor-link, h5:hover .anchor-link, h6:hover .anchor-link { visibility: visible; } .text_cell.rendered .input_area { display: none; } .text_cell.rendered .text_cell.rendered .rendered_html tr, .text_cell.rendered .rendered_html th, .text_cell.rendered .text_cell.unrendered .text_cell_render { display: none; } .text_cell .dropzone .input_area { border: 2px dashed #bababa; margin: -1px; } .cm-header-1, .cm-header-2, .cm-header-3, .cm-header-4, .cm-header-5, .cm-header-6 { font-weight: bold; font-family: \"Helvetica Neue\", Helvetica, Arial, sans-serif; } .cm-header-1 { font-size: 185.7%; } .cm-header-2 { font-size: 157.1%; } .cm-header-3 { font-size: 128.6%; } .cm-header-4 { font-size: 110%; } .cm-header-5 { font-size: 100%; font-style: italic; } .cm-header-6 { font-size: 100%; font-style: italic; } .highlight .hll { background-color: #ffffcc } .highlight { background: #f8f8f8; } .highlight .c { color: #408080; font-style: italic } /* Comment */ .highlight .err { border: 1px solid #FF0000 } /* Error */ .highlight .k { color: #008000; font-weight: bold } /* Keyword */ .highlight .o { color: #666666 } /* Operator */ .highlight .ch { color: #408080; font-style: italic } /* Comment.Hashbang */ .highlight .cm { color: #408080; font-style: italic } /* Comment.Multiline */ .highlight .cp { color: #BC7A00 } /* Comment.Preproc */ .highlight .cpf { color: #408080; font-style: italic } /* Comment.PreprocFile */ .highlight .c1 { color: #408080; font-style: italic } /* Comment.Single */ .highlight .cs { color: #408080; font-style: italic } /* Comment.Special */ .highlight .gd { color: #A00000 } /* Generic.Deleted */ .highlight .ge { font-style: italic } /* Generic.Emph */ .highlight .gr { color: #FF0000 } /* Generic.Error */ .highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */ .highlight .gi { color: #00A000 } /* Generic.Inserted */ .highlight .go { color: #888888 } /* Generic.Output */ .highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */ .highlight .gs { font-weight: bold } /* Generic.Strong */ .highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */ .highlight .gt { color: #0044DD } /* Generic.Traceback */ .highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */ .highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */ .highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */ .highlight .kp { color: #008000 } /* Keyword.Pseudo */ .highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */ .highlight .kt { color: #B00040 } /* Keyword.Type */ .highlight .m { color: #666666 } /* Literal.Number */ .highlight .s { color: #BA2121 } /* Literal.String */ .highlight .na { color: #7D9029 } /* Name.Attribute */ .highlight .nb { color: #008000 } /* Name.Builtin */ .highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */ .highlight .no { color: #880000 } /* Name.Constant */ .highlight .nd { color: #AA22FF } /* Name.Decorator */ .highlight .ni { color: #999999; font-weight: bold } /* Name.Entity */ .highlight .ne { color: #D2413A; font-weight: bold } /* Name.Exception */ .highlight .nf { color: #0000FF } /* Name.Function */ .highlight .nl { color: #A0A000 } /* Name.Label */ .highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */ .highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */ .highlight .nv { color: #19177C } /* Name.Variable */ .highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */ .highlight .w { color: #bbbbbb } /* Text.Whitespace */ .highlight .mb { color: #666666 } /* Literal.Number.Bin */ .highlight .mf { color: #666666 } /* Literal.Number.Float */ .highlight .mh { color: #666666 } /* Literal.Number.Hex */ .highlight .mi { color: #666666 } /* Literal.Number.Integer */ .highlight .mo { color: #666666 } /* Literal.Number.Oct */ .highlight .sa { color: #BA2121 } /* Literal.String.Affix */ .highlight .sb { color: #BA2121 } /* Literal.String.Backtick */ .highlight .sc { color: #BA2121 } /* Literal.String.Char */ .highlight .dl { color: #BA2121 } /* Literal.String.Delimiter */ .highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */ .highlight .s2 { color: #BA2121 } /* Literal.String.Double */ .highlight .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */ .highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */ .highlight .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */ .highlight .sx { color: #008000 } /* Literal.String.Other */ .highlight .sr { color: #BB6688 } /* Literal.String.Regex */ .highlight .s1 { color: #BA2121 } /* Literal.String.Single */ .highlight .ss { color: #19177C } /* Literal.String.Symbol */ .highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */ .highlight .fm { color: #0000FF } /* Name.Function.Magic */ .highlight .vc { color: #19177C } /* Name.Variable.Class */ .highlight .vg { color: #19177C } /* Name.Variable.Global */ .highlight .vi { color: #19177C } /* Name.Variable.Instance */ .highlight .vm { color: #19177C } /* Name.Variable.Magic */ .highlight .il { color: #666666 } /* Literal.Number.Integer.Long */ Neural Network Table of contents 単純パーセプロトン (Perceptron) 多層パーセプロトン (Multilayer Perceptron) 誤差逆伝播法 (Back Propagation) 実装 (Implementation) 1. 単純パーセプロトン (Perceptron) ニューラルネットワークは 多数の素子（パーセプトロン）の集まり で表現されます。そこで、まずは１つ１つの素子、パーセプロトンを見ていきます。 単一の素子は以下の図のように表され、入力を受け取り、 その値（の和）がある閾値 $\\theta$ を超えたら発火して出力 $\\theta$ 以下だったら出力しない という性質を持ちます。 この性質を数学的に記述すると、 重みパラメータ：$w_0,w_1,\\ldots,w_m$ 活性化関数：$h$ から構成される以下のような関数として書けます。 $$f(x_1,x_2,\\ldots,x_m) = h(w_1x_1+w_2x_2+\\cdots+w_Nx_N+w_0)$$ この時 $w_0$ は バイアスパラメータ(bias parameter) と呼ばれ、 関数を平行移動させる 役割を果たします。 活性化関数(activation function) 活性化関数は、 「ある閾値 $\\theta$ を超えたら発火して出力し、$\\theta$ 以下だったら出力しない」 という神経の性質を表現するための関数であり、最も単純なものとしては以下で表される ヘヴィサイド関数(Heaviside function) があります。 $$h(a) = \\left\\{\\begin{array}{cc}0 & (\\theta < 0) \\\\1 & (\\theta > 0)\\end{array}\\right.$$ この性質は表したい能力を如実に表してはいますが、 不連続であり扱いづらい ため、実際は ロジスティックシグモイド関数 ： $$h(a) = \\frac{1}{1+\\exp(-a)}\\qquad(4.59)$$ ハイパボリックタンジェント関数 ： $$\\begin{aligned}h(a) &= \\tanh (a)\\\\&=\\frac{e&#94;a-e&#94;{-1}}{e&#94;1+e&#94;{-1}} &(5.59)\\end{aligned}$$ ソフトマックス関数 ： $$h(\\mathbf{a}) = \\frac{\\exp(a_i)}{\\sum_j \\exp(a_i)}\\qquad (4.63)$$ などが用いられることが多いです。 ※ Kerasyでは ここ で定義しています。 In [1]: class Linear (): def forward ( input ): return input def diff ( delta ): return delta class Tanh (): def forward ( input ): return np . tanh ( input ) def diff ( delta ): return 1 - np . tanh ( delta ) ** 2 ActivationHandler = { 'linear' : Linear , 'tanh' : Tanh , } def ActivationFunc ( activation_func_name ): return ActivationHandler [ activation_func_name ] 2. 多層パーセプロトン (Multilayer Perceptron) それでは、複数の単子（単純パーセプロトン）を繋げて２層のパーセプトロンを作ります。なお、 ２層以上のパーセプトロンを ニューラルネットワーク と言います。 例えば１層目に $m$ 個の素子を用意し、入力が $D$ 次元の場合、関数で表すと $$y = h_2\\left(\\sum_{i=0}&#94;{m} w&#94;{(2)}_ih_1\\left(\\sum_{j=0}&#94;{D}w&#94;{(1)}_{ij} x_j\\right)\\right)\\qquad(5.9)$$ となります。 記号 意味 $w&#94;{(1)}_{ij}$ $1$ 層目の $i$ 番目の素子への入力 $x_j$ の重み $w&#94;{(2)}_i$ $1$ 層目の $i$ 番目の素子から $2$ 層目の素子への入力の重み $h_1,h_2$ それぞれの層の活性化関数 多層にする意味 単純パーセプロトン： $$ y=f\\left(\\sum_i w_i\\textcolor{red}{\\phi_i(\\mathbf{x})}\\right) \\qquad(5.1)$$ $2$ 層パーセプトロン： $$ y = h_2\\left(\\sum_{i=0}&#94;{m} w&#94;{(2)}_i\\textcolor{red}{h_1\\left(\\sum_{j=0}&#94;{D}w&#94;{(1)}_{ij} x_j\\right)}\\right)\\qquad(5.9)$$ この式から分かるように、基底 $\\phi_i(\\mathbf{x})$ が $\\displaystyle h_1\\left(\\sum_{j=0}&#94;{D}w&#94;{(1)}_{ij} x_j\\right)$ に置き換わっていることがわかります。 これによって、 単一だと「固定」されていた基底関数が、多層になることで「適応的に変動」する ようになります。ゆえに、 十分大きな $m$ をとり、活性化関数が非線形な多層パーセプトロンは、 任意の関数を任意の精度で近似することができる という性質を持ちます。 3. 誤差逆伝播法 (Back Propagation) ニューラルネットワークについて語る上で避けては通れなく、理解が難しいのが 誤差逆伝播法（back propagation） です。 しかし、誤差逆伝播法とは 「ニューラルネットワークを学習させる際に用いられる効率的な計算方法」 のことで、簡単に言ってしまえば 「合成関数の微分則」 です。また、ネットワークの訓練とは、 「（重みを変化させることで）訓練データの出力と正解の誤差 $E_n(\\mathbf{w})$ を最小化すること」 を指します。 以下、 素子 $i$ の出力を $z_i$ 素子 $j$ への入力和を $a_j$ として、説明します。 学習のプロセスにおいては 「素子 $i$ から素子 $j$ への接続の重み $w_{ji}$ として、全ての $i,j$ の組合せ（＝全ノードの重み）に対して$ \\frac{\\partial E_n}{\\partial w_{ji}} $を計算すること」 が目標となります。 すると、上の図のように 「$E_n$ は $a_j$ を介してのみ $w_{ji}$ に依存する」（＝ $w_{ji}$ が変化すると $a_j$ が変化し、それが $E_n$ に影響を及ぼす） ことに注意すれば $$ \\frac{\\partial E_n}{\\partial w_{ji}} = \\frac{\\partial E_n}{\\partial a_j}\\frac{\\partial a_j}{\\partial w_{ji}}\\qquad(5.50)$$ となります。また、ここで $\\delta_j = \\partial E_n/\\partial a_j$ と書くことにし、これを 誤差 と呼びます。 続いて、$\\delta_i$ について考えると、$E_n$ は素子 $i$ の出力を受け取る素子 $j$ の入力 $a_j$ を介して $a_i$ に依存するので、合成微分則より $$ \\delta_i = \\frac{\\partial E_n}{\\partial a_i} = \\sum_j \\frac{\\partial E_n}{\\partial a_j}\\frac{\\partial a_j}{\\partial a_i} = \\sum_j\\delta_j\\frac{\\partial a_j}{\\partial a_i}\\qquad(5.55)$$ となります。（下図参照） さらに、素子 $i$ の活性化関数を $h_i$ とすると、 $$a_j = \\sum_i w_{ji} h_i(a_i)\\qquad(5.48)$$ だった（素子 $i$ への入力和を活性化関数に通しそれぞれに重み $w_{ji}$ をかけた和を素子 $j$ に伝える）ので、 $$ \\frac{\\partial a_j}{\\partial a_i} = w_{ji} h_i'(a_i)$$ となります。 ここまでをまとめると、誤差 $\\delta_i$ の逆伝播公式 $$ \\delta_i = h_i'(a_i) \\sum_j w_{ji}\\delta_j\\qquad(5.56)$$ が得られます。 また、ネットワークの出力部における $\\delta$ の値は直接計算する事が出来るので、そこから逆にネットワークを辿りながら各 $\\delta$ を計算する事が可能になります。 このネットワークを逆に辿る過程で各 $w_{ji}$ に対する $W$ 個の偏導関数を一回の誤差伝播で求めてしまう事が出来るので、 大変効率の良いアルゴリズム となっています。 【まとめ】 データ $\\mathbf{x}_n$ を入力した時の、各素子への入力 $a_i$ 出力 $z_i$ を求める ネットワークの出力部における誤差 $\\delta_i$ を計算する 逆伝播公式を利用して各素子における $\\delta_i$ を計算する。 $$\\delta_i = h_i'(a_i) \\sum_j w_{ji}\\delta_j$$ 以下を利用して必要な偏微分係数を求める。 $$\\frac{\\partial E_n}{\\partial w_{ji}} = \\delta_j z_i$$ 4. 実装 (Implementation) In [2]: import numpy as np import matplotlib.pyplot as plt 初期化 In [3]: def Zeros ( shape , dtype = None ): return np . zeros ( shape = shape , dtype = dtype ) def RandomNormal ( shape ): return np . random . normal ( loc = 0 , scale = 0.05 , size = shape ) InitializeHandler = { 'zeros' : Zeros , 'random_normal' : RandomNormal , } def Initializer ( initializer_name ): return InitializeHandler [ initializer_name ] 誤差関数 In [4]: class mean_squared_error (): def loss ( y_true , y_pred ): return np . mean ( np . square ( y_pred - y_true ), axis =- 1 ) def diff ( y_true , y_pred ): return y_pred - y_true LossHandler = { 'mean_squared_error' : mean_squared_error , } def LossFunc ( loss_func_name ): return LossHandler [ loss_func_name ] 各層 In [5]: class Layers (): NLayers = 1 def __init__ ( self , name , units ): self . name = f \"Layer {Layers.NLayers} . {name} \" self . outdim = units self . w = None Layers . NLayers += 1 def build ( self , indim ): self . indim = indim self . w = np . c_ [ self . kernel_initializer ( shape = ( self . outdim , self . indim )), self . bias_initializer ( shape = ( self . outdim , 1 )) ] class Input ( Layers ): def __init__ ( self , inputdim ): super () . __init__ ( \"inputs\" , inputdim ) class Dense ( Layers ): def __init__ ( self , units , activation = 'linear' , kernel_initializer = 'random_normal' , bias_initializer = 'zeros' ): \"\"\" @param units : (tuple) dimensionality of the (input space, output space). @param activation : (str) Activation function to use. @param kernel_initializer: (str) Initializer for the `kernel` weights matrix. @param bias_initializer : (str) Initializer for the bias vector. \"\"\" super () . __init__ ( \"dense\" , units ) self . kernel_initializer = Initializer ( kernel_initializer ) self . bias_initializer = Initializer ( bias_initializer ) self . h = ActivationFunc ( activation ) self . z = None self . a = None def forward ( self , input ): \"\"\" @param input: shape=(Din,) \"\"\" z_in = np . append ( input , 1 ) # shape=(Din+1,) a = self . w . dot ( z_in ) # (Dout,Din+1) @ (Din+1,) = (Dout,) z_out = self . h . forward ( a ) # shape=(Dout,) self . z = z_in self . a = a return z_out def backprop ( self , dEdz_out ): \"\"\" @param dEdz_out: shape=(Dout,) \"\"\" dEda = self . h . diff ( self . a ) * dEdz_out # δ, shape=(Dout,) dEdz_in = self . w . T . dot ( dEda ) # (Din+1,Dout) @ (Dout,) = (Din+1,) self . update ( dEda ) return dEdz_in [: - 1 ] # shape=(Din,) term of bias is not propagated. def update ( self , delta , ALPHA = 0.01 ): \"\"\" @param delta: shape=(Dout,) \"\"\" dw = np . outer ( delta , self . z ) # (Dout,) × (Din+1,) = (Dout,Din+1) self . w -= ALPHA * dw モデル（各層のスタック） In [6]: class Sequential (): def __init__ ( self , layer = None ): self . layers = [] self . epochs = 0 if layer is not None : self . add ( layer ) self . loss = None self . config = None def add ( self , layer ): \"\"\"Adds a layer instance.\"\"\" self . layers . append ( layer ) def compile ( self , loss , input_shape = None ): \"\"\" Creates the layer weights. \"\"\" self . loss = LossFunc ( loss ) units = [ l . outdim for l in self . layers ] for i , l in enumerate ( self . layers ): if l . name [ - 6 :] == \"inputs\" : continue l . build ( indim = units [ i - 1 ]) def fit ( self , x_train , y_train , epochs = 1000 ): goal_epochs = self . epochs + epochs digit = len ( str ( self . epochs )) for e in range ( epochs ): for x , y in zip ( x_train , y_train ): out = self . forward ( x ) self . backprop ( y , out ) self . epochs += 1 y_pred = self . predict ( x_train ) mse = np . mean (( y_pred - y_train ) ** 2 ) if self . epochs % 100 == 99 : print ( f '[{self.epochs+1: {digit} d}/{goal_epochs: {digit} d}] mse={mse: {4} f}' ) def forward ( self , input ): out = input for l in self . layers : if l . name [ - 6 :] == \"inputs\" : continue out = l . forward ( out ) return out def backprop ( self , y_true , out ): dEdz_out = self . loss . diff ( y_true , out ) for l in reversed ( self . layers ): if l . name [ - 6 :] == \"inputs\" : continue dEdz_out = l . backprop ( dEdz_out ) def predict ( self , x_train ): if np . ndim ( x_train ) == 1 : return self . forward ( x_train ) else : return np . array ([ self . forward ( x ) for x in x_train ]) 実装例 In [7]: model = Sequential ( Input ( 1 )) model . add ( Dense ( 3 , activation = \"tanh\" , kernel_initializer = \"random_normal\" , bias_initializer = \"zeros\" )) model . add ( Dense ( 3 , activation = \"tanh\" , kernel_initializer = \"random_normal\" , bias_initializer = \"zeros\" )) model . add ( Dense ( 1 , activation = \"tanh\" )) In [8]: print ( \"Units: {} \" . format ([ l . outdim for l in model . layers ])) print ( \"Layers: {} \" . format ([ l . name for l in model . layers ])) print ( \"Weights: {} \" . format ([ l . w for l in model . layers ])) model . compile ( loss = \"mean_squared_error\" ) print ( \"Weights: {} \" . format ([ l . w . shape if l . w is not None else None for l in model . layers ])) Units: [1, 3, 3, 1] Layers: ['Layer1.inputs', 'Layer2.dense', 'Layer3.dense', 'Layer4.dense'] Weights: [None, None, None, None] Weights: [None, (3, 2), (3, 4), (1, 4)] In [9]: N = 1000 func = lambda x : x ** 2 X = np . linspace ( - 1 , 1 , N ) . reshape ( - 1 , 1 ) Y = np . vectorize ( func )( X ) In [10]: model . fit ( X , Y ) [100/1000] mse=0.010276 [200/1000] mse=0.006744 [300/1000] mse=0.001597 [400/1000] mse=0.000826 [500/1000] mse=0.000794 [600/1000] mse=0.000754 [700/1000] mse=0.000715 [800/1000] mse=0.000685 [900/1000] mse=0.000664 [1000/1000] mse=0.000646 In [11]: Y_pred = model . predict ( X ) In [12]: plt . plot ( X , Y_pred , label = \"Neural Network\" , color = \"red\" ) plt . scatter ( X , Y , s = 1 , label = \"data\" , color = \"blue\" ) plt . xlabel ( \"x\" ) plt . ylabel ( \"y\" ) plt . legend () plt . show () /*蛍光ペン(pink)*/ .marker-pink { color: #c45a5a; background: linear-gradient(transparent 70%, #ff66ff 60%); font-weight: bold; } /*蛍光ペン(blue) & hover info*/ .marker-info { color: #5C7DC4; background: linear-gradient(transparent 70%, #66FFCC 60%); font-weight: bold; position: relative; cursor: pointer; } .marker-info:hover:before { opacity: 1; } .marker-info:before { content: attr(aria-label); opacity: 0; position: absolute; top: 30px; right: -90px; font-size: 14px; width: 300px; padding: 10px; color: #fff; background-color: #555; border-radius: 3px; pointer-events: none; } In [ ]: if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) { var mathjaxscript = document.createElement('script'); mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#'; mathjaxscript.type = 'text/javascript'; mathjaxscript.src = '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'; mathjaxscript[(window.opera ? \"innerHTML\" : \"text\")] = \"MathJax.Hub.Config({\" + \" config: ['MMLorHTML.js'],\" + \" TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } },\" + \" jax: ['input/TeX','input/MathML','output/HTML-CSS'],\" + \" extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js'],\" + \" displayAlign: 'center',\" + \" displayIndent: '0em',\" + \" showMathMenu: true,\" + \" tex2jax: { \" + \" inlineMath: [ ['$','$'] ], \" + \" displayMath: [ ['$$','$$'] ],\" + \" processEscapes: true,\" + \" preview: 'TeX',\" + \" }, \" + \" 'HTML-CSS': { \" + \" styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'black ! important'} }\" + \" } \" + \"}); \"; (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript); }","tags":"Kerasy","url":"https://iwasakishuto.github.io/Kerasy/doc/NeuralNetworks.html","loc":"https://iwasakishuto.github.io/Kerasy/doc/NeuralNetworks.html"}]};